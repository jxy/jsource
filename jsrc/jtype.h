/* Copyright 1990-2007, Jsoftware Inc.  All rights reserved.               */
/* Licensed use only. Any other use is in violation of copyright.          */
/*                                                                         */
/* Type Definitions                                                        */

#define U unsigned

#if (SYS & SYS_UNIX)
#define _stdcall      
#endif

#if SY_64
typedef long long          A1;
typedef unsigned long long BT;
typedef long long          I;
typedef long long          SB;
typedef unsigned long long UI;
typedef unsigned long long UIL;   /* for typecast 8 byte double */
typedef long long          IL;
//NANFLAG is used internally as a special value that is not generated by any normal operations.  It is represented in integer form,
// and is used only when SZI==SZD
#define NANFLAG 0x7ff28da91LL  // signaling NaN with a particular value

#else
typedef long               A1;
typedef unsigned long      BT;
typedef long               I;
typedef long               SB;
typedef unsigned long      UI;
typedef unsigned long long UIL;
typedef long long          IL;
#endif

typedef char               B;
typedef unsigned char      C;
typedef char*              Ptr;
typedef short              S;
typedef short              C2;
typedef unsigned int       C4;
typedef unsigned char      UC;
typedef unsigned short     US;
typedef unsigned short     U2;
typedef unsigned int       UINT;
typedef int                I4;
typedef unsigned int       UI4;
typedef double             D;
typedef float              DS;
typedef FILE*              F;

typedef long double        LD;

// This is the main structure for J entities
typedef US                 RANKT;
#define RANKTX             16   // # bits in a RANKT
#define RANKTMSK           (((I)1<<RANKTX)-1)
#define R2MAX              ((RMAX<<RANKTX)+RMAX)  // max value of a RANK2T
typedef UI4                RANK2T;  // 2 ranks, (l<<16)|r
typedef I                  FLAGT;
typedef UI4                LX;  // index of an L block in jt->sympv

typedef struct AD AD;
typedef AD *A;

// Flag bits in the low-order part of jt - used only if the function being called understands inplacing
#define JTINPLACEWX     0   // turn this on in jt to indicate that w can be inplaced
#define JTINPLACEW      (((I)1)<<JTINPLACEWX)
#define JTINPLACEAX     1   // turn this on in jt to indicate that a can be inplaced.  Must be 1+JTINPLACEWX
#define JTINPLACEA      (((I)1)<<JTINPLACEAX)
// Next flag must match result.h and VF2 flags
#define JTWILLBEOPENEDX 4   // result of this exec will be opened immediately, so it can contain virtual references to an input to the current verb
#define JTWILLBEOPENED  (((I)1)<<JTWILLBEOPENEDX)
#define JTEMPTYX        5  // in va2, this bit indicates the result is empty
#define JTEMPTY         (((I)1)<<JTEMPTYX)
#define JTRETRYX        6  // in va2, this bit is set to indicate that the current execution is a retry
#define JTRETRY         (((I)1)<<JTRETRYX)

// Next flag must match result.h and VF2 flags
#define JTCOUNTITEMSX   7   // result of this exec will be go into ;, so an item count in m would be helpful
#define JTCOUNTITEMS    (((I)1)<<JTCOUNTITEMSX)

#define JTFLAGMSK       255  // mask big enough to cover all defined flags
#define JTALIGNBDY      8192  // jt is aligned on this boundary - all lower bits are 0 (the value is the size of an SDRAM page, to avoid row precharges while accessing jt)


struct AD {
 union {
  I k;
  A chain;   // used when block is on free chain
  A globalst;  // for local symbol tables (SYMB types), AK points to the active global symbol table when the current sentence started parsing
 } kchain;
 FLAGT flag;
 union {
  I m;  // Multi-use field. (1) For NJA/SMM blocks, size of allocation. (2) for blocks coming out of a COUNTITEMS verb, holds the number of items in the
        // raze of the noun (if the types are identical) (3) for SYMB tables for explicit definitions, the address of the calling symbol table (4) for the block
        // holding the amend offsets in x u} y, the number of axes of y that are built into the indexes in u (5) for name references, the value of jt->modifiercount when the name was last looked up
  A back; // For VIRTUAL blocks, points to backing block

} mback;
 union {
  I t;  // type
  A proxychain;  // used when block is on free chain
 } tproxy;
 I c;  // usecount
//  NOTE!! result.h faux cellshape block depends on n, r, and s being in place from here to the end of this struct, with 2 Is from n to s
 I n;  // # atoms - always 1 for sparse arrays
#if C_LE
 RANKT r;  // rank
 US h;   // reserved for allocator.  Not used for AFNJA memory
#if BW==64
 UI4 fill;   // On 64-bit systems, there will be a padding word here - insert in case compiler doesn't
#endif
#else
#if BW==64
 UI4 fill;   // On 64-bit systems, there will be a padding word here - insert in case compiler doesn't
#endif
 US h;   // reserved for allocator.  Not used for AFNJA memory
 RANKT r;  // rank
#endif
 I s[1];   // shape starts here
};

typedef struct {A a,t;}TA;
typedef A                (*AF)();
typedef UI               (*UF)();
typedef void             (*VF)();
typedef B                (*CMP)();    /* comparison function in sort     */
typedef A                  X;
typedef struct {X n,d;}    Q;
typedef struct {D re,im;}  Z;
typedef union {D d;UINT i[2];UI ui;} DI;

#if (SYS & SYS_PC+SYS_MACINTOSH)        /* for use by the session manager  */
typedef S SI;
#else
typedef I SI;
#endif

/* Fields of type A                                                        */

#define AK(x)           ((x)->kchain.k)        /* offset of ravel wrt x           */
#define AKGST(x)        ((x)->kchain.globalst)        // global symbol table for this local symbol table
#define AFLAG(x)        ((x)->flag)     /* flag                            */
#define AM(x)           ((x)->mback.m)        /* Max # bytes in ravel            */
#define ABACK(x)        ((x)->mback.back)        /* In virtual noun, pointer to backing block            */
#define AT(x)           ((x)->tproxy.t)        /* Type; one of the #define below  */
#define AC(x)           ((x)->c)        /* Reference count.                */
#define AN(x)           ((x)->n)        /* # elements in ravel             */
#define AR(x)           ((x)->r)        /* Rank                            */
#define SMMAH           7L   // number of header words in old-fashioned SMM alloc
#define NORMAH          7L   // number of header words in new system
#define AS(x)           ((x)->s)        // Because s is an array, AS(x) is a pointer to the shape, which is in s.  The shape is stored in the fixed position s.

// The following fields are used for private communication between /. and ;. and inside ;. for the fret buffer.
#define CUTFRETCHAIN(x) ((x)->kchain.chain)  // pointer to next block of frets
#define CUTFRETCOUNT(x) ((x)->kchain.k)  // when passed into cut, this is # frets.  Overwritten by CUTFRETCHAIN
#define CUTFRETFRETS(x) ((UC*)((x)->s))   // address of first fret
#define CUTFRETEND(x)   ((x)->n)   // address of last+1 fret

#if SY_64
#define AKXR(x)         (SZI*(NORMAH+(x)))
#define WP(t,n,r)       (SMMAH+ r   +(1&&t&LAST0)+(((t&NAME?sizeof(NM):0)+((n)<<bplg(t))+SZI-1)>>LGSZI))  // # I to allocate
#else
#define AKXR(x)         (SZI*(NORMAH+((x)|1)))
#define WP(t,n,r)       (SMMAH+(r|1)+  (1&&t&LAST0)+(((t&NAME?sizeof(NM):0)+((n)<<bplg(t))+SZI-1)>>LGSZI))
/* r|1 to make sure array values are double-word aligned */
#endif
#define AKX(x)          AKXR(AR(x))

#define AV(x)           ( (I*)((C*)(x)+AK(x)))  /* pointer to ravel        */
#define BAV(x)          (      (C*)(x)+AK(x) )  /* boolean                 */
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
#define UCAV(x)         (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define USAV(x)         ((US*)((C*)(x)+AK(x)))  /* wchar                   */
#define UAV(x)          (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define UIAV(x)         ((UI*)((C*)(x)+AK(x)))  /* unsigned character      */
#define UI4AV(x)        ((UI4*)((C*)(x)+AK(x)))  /* unsigned 32-bit int      */
#define C4AV(x)         ((C4*)((C*)(x)+AK(x)))  /* literal4                */
#define NAV(x)          ((NM*)((C*)(x)+AKXR(1)))  // name, which is always allocated as rank 1, for some reason
#define IAV(x)          AV(x)                   /* integer                 */
#define IAV0(x)         ((I*)((C*)(x)+AKXR(0)))  // integer in a stack- or heap-allocated atom (rank 0 - used for internal tables)
#define IAV1(x)         ((I*)((C*)(x)+AKXR(1)))  // integer in a stack- or heap-allocated list (rank 1)
#define BAV0(x)         ( (C*)((C*)(x)+AKXR(0)) )  // Boolean when rank is 0 - fixed position (known to avoid segfault)
#define LXAV0(x)        ( (LX*)((C*)(x)+AKXR(0)) )  // Integer when rank is 0 - fixed position (for SYMB tables).  Note AK() is used in SYMB tables
#define DAV(x)          ( (D*)((C*)(x)+AK(x)))  /* double                  */
#define ZAV(x)          ( (Z*)((C*)(x)+AK(x)))  /* complex                 */
#define XAV(x)          ( (X*)((C*)(x)+AK(x)))  /* extended                */
#define QAV(x)          ( (Q*)((C*)(x)+AK(x)))  /* rational                */
#define AAV(x)          ( (A*)((C*)(x)+AK(x)))  /* boxed                   */
#define A1AV(x)         ((A1*)((C*)(x)+AK(x)))  /* boxed relative address  */
#define VAV(x)          ( (V*)((C*)(x)+AK(x)))  /* verb, adverb, conj      */
#define FAV(x)          ( (V*)((C*)(x)+AKXR(0)) )  // verb, adverb, conj - always at fixed offset
#define PAV(x)          ( (P*)((C*)(x)+AK(x)))  /* sparse                  */
#define SBAV(x)         ((SB*)((C*)(x)+AK(x)))  /* symbol                  */
#define voidAV(x)       ((void*)((C*)(x)+AK(x)))  // unknown

#define AAV0(w) AAV(w)[0]
#if C_LE
#define BIV0(w) (IAV(w)[0]&(1-(AT(w)>>1)))  // the first (presumably only) value in w, when w is an INT or B01 type
#endif

/* Types for AT(x) field of type A                                         */
/* Note: BOOL name conflict with ???; SCHAR name conflict with sqltypes.h  */

// NOTE!! the length of NOUN types must be power-of-2 multiples because of jtamend2

// NOTE: all noun types must be below all parsable non-nouns

#define B01X 0
#define B01             ((I)1L<<B01X)           /* B  boolean                      */
#define B01SIZE         sizeof(B)       // length of 1 atom
#define LITX 1
#define LIT             ((I)1L<<LITX)           /* C  literal (character)          */
#define LITSIZE sizeof(C)
#define INTX 2
#define INT             ((I)1L<<INTX)           /* I  integer                      */
#define INTSIZE sizeof(I)
#define FLX 3
#define FL              ((I)1L<<FLX)           /* D  double (IEEE floating point) */
#define FLSIZE sizeof(D)
#define CMPXX 4
#define CMPX            ((I)1L<<CMPXX)          /* Z  complex                      */
#define CMPXSIZE sizeof(Z)
#define BOXX 5
#define BOX             ((I)1L<<BOXX)          /* A  boxed                        */
#define BOXSIZE sizeof(A)
#define XNUMX 6
#define XNUM            ((I)1L<<XNUMX)          /* X  extended precision integer   */
#define XNUMSIZE sizeof(X)
#define RATX 7
#define RAT             ((I)1L<<RATX)         /* Q  rational number              */
#define RATSIZE sizeof(Q)
#define BITX 8
#define BIT             ((I)1L<<BITX)         /* BT bit boolean                  */
// No size for BIT, since it is fractional
// Bit 9 unused
#define SB01X 10
#define SB01            ((I)1L<<SB01X)        /* P  sparse boolean               */
#define SB01SIZE sizeof(P)
#define SLITX 11
#define SLIT            ((I)1L<<SLITX)        /* P  sparse literal (character)   */
#define SLITSIZE sizeof(P)
#define SINTX 12
#define SINT            ((I)1L<<SINTX)        /* P  sparse integer               */
#define SINTSIZE sizeof(P)
#define SFLX 13
#define SFL             ((I)1L<<SFLX)        /* P  sparse floating point        */
#define SFLSIZE sizeof(P)
#define SCMPXX 14
#define SCMPX           ((I)1L<<SCMPXX)       /* P  sparse complex               */
#define SCMPXSIZE sizeof(P)
#define SBOXX 15
#define SBOX            ((I)1L<<SBOXX)       /* P  sparse boxed                 */
#define SBOXSIZE sizeof(P)
#define SBTX 16
#define SBT             ((I)1L<<SBTX)       /* SB symbol                       */
#define SBTSIZE sizeof(SB)
#define C2TX 17
#define C2T             ((I)1L<<C2TX)      /* C2 unicode (2-byte characters)  */
#define C2TSIZE sizeof(US)
#define C4TX 18
#define C4T             ((I)1L<<C4TX)         /* C4 unicode (4-byte characters)  */
#define C4TSIZE sizeof(C4)
#define XDX 19
#define XD              ((I)1L<<XDX)   // DX extended floating point   used to represent intolerant compare in jtiosc
#define XDSIZE sizeof(DX)
#define XZX 20
#define XZ              ((I)1L<<XZX)   /* ZX extended complex             */
#define XZSIZE sizeof(ZX)

#define LASTNOUNX XZX    // index of last noun bit

// ASGN see below
#define MARKX 22
#define MARK            ((I)1L<<MARKX)     /* I  end-of-stack marker          */
#define MARKSIZE sizeof(I)
#define NAMEX 23
#define NAME            ((I)1L<<NAMEX)    /* NM name                         */
#define NAMESIZE sizeof(C)   // when we allocate a NAME type, the length is the length of the name string
#define SYMBX 24
#define SYMB            ((I)1L<<SYMBX)     /* I  locale (symbol table)        */
#define SYMBSIZE sizeof(LX)
#define CONWX 25
#define CONW            ((I)1L<<CONWX)    /* CW control word                 */
#define CONWSIZE sizeof(CW)
#define LPARX 26
#define LPAR            ((I)1L<<LPARX)    /* I  left  parenthesis            */
#define LPARSIZE sizeof(I)
#define VERBX 27
#define VERB            ((I)1L<<VERBX)      /* V  verb                         */
#define VERBSIZE sizeof(V)  // Note: size of ACV in bp() is INTSIZE because the allocation in fdef() is of INTs
#define ADVX 28
#define ADV             ((I)1L<<ADVX)      /* V  adverb                       */
#define ADVSIZE sizeof(V)
// CONJ must be 1 bit below RPAR, with no parsable type (including any flags that might be set, see below) higher than RPAR
#define CONJX 29
#define CONJ            ((I)1L<<CONJX)     /* V  conjunction                  */
#define CONJSIZE sizeof(V)
#define RPARX 30
#define RPAR            ((I)1L<<RPARX)   /* I  right parenthesis            */
#define RPARSIZE sizeof(I)
// NOTE maxtype & maybe others require bit 31 to be 0!!
#define RESVX 31    // reserved so types can be I types

#define ASGNX 21
#define ASGN            ((I)1L<<ASGNX)     /* I  assignment                   */
#define ASGNSIZE sizeof(I)     // only 1 byte, but all non-DIRECT are fullword multiples
// ** ASGN type can have the following informational bits set along with ASGN
#define ASGNLOCAL       ((I)1L<<SYMBX)     // set for =. (but not when assigning to locative)    aliases with SYMB
#define ASGNTONAME      ((I)1L<<CONWX)     // set when assignment is to name    aliases with CONW
// NOTE: The parser assumes that CONW always means ASGNTONAME, so don't use it in any parseable type (such as NAME, NOUN)
// ** NOUN types can have the following informational bits set
#define NOUNCVTVALIDCT  ((I)1L<<SYMBX)     // Flag for jtcvt: if set, convert only the #atoms given in the parameter   Aliases with SYMB
// ** NAME type can have the following information flags set
#define NAMEBYVALUE     ((I)1L<<SYMBX)     // set if the name is one of x x. m m. etc that is always passed by value, never by name   Aliases with SYMB
// BOX type can have the following informational flags set
#define BOXMULTIASSIGN  ((I)1L<<MARKX)     // set for the target of a direct multiple assignment (i. e. 'x y' =.), which is stored as a boxed list whose contents are NAMEs    aliases with MARK
// Restriction: CONW must be reserved for use as ASGNTONAME because of how parser tests for it
// Restriction: MARK must be reserved for use as BOXMULTIASSIGN because of how parser tests for it

// Planned coding to save bits in type
// Uses bits 24-27 eg
// MARK is represented by type of all 0
// Other types are in bits 24-27:
// CONJ   0001
// ADV    0101
// VERB   1101
// ASGN   xy10    x=ASGNLOCAL y=ASGNTONAME
// CONW   0100    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type
// SYMB   1100
// NAME   100v    v=NAMEBYVALUE
// RPAR   0011    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type
// LPAR   1011    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type

#define ANY             -1L
#define SPARSE          (SB01+SINT+SFL+SCMPX+SLIT+SBOX)
#define NUMERIC         (B01+BIT+INT+FL+CMPX+XNUM+RAT+SB01+SINT+SFL+SCMPX)
#define DIRECT          (LIT+C2T+C4T+B01+BIT+INT+FL+CMPX+SBT)
#define JCHAR           (LIT+C2T+C4T+SLIT)
#define NOUN            (NUMERIC+JCHAR+BOX+SBOX+SBT)
#define DENSE           (NOUN&~SPARSE)
#define FUNC            (VERB+ADV+CONJ)
#define RHS             (NOUN+FUNC)
#define IS1BYTE         (B01+LIT)
#define LAST0           (B01+LIT+C2T+C4T+NAME)
// Don't call traverse unless one of these bits is set
#define TRAVERSIBLE     (RAT|XNUM|BOX|VERB|ADV|CONJ|SB01|SINT|SFL|SCMPX|SLIT|SBOX)
// Allow recursive usecount in one of these types
#define RECURSIBLE      (BOX|VERB|ADV|CONJ|RAT|XNUM)
// Modifiers that operate on subarrays do so with virtual blocks, and those blocks may be marked as inplaceable if the backing block is inplaceable.
// The inplaceability applies to the data area, but not necessarily to the block header: if UNINCORPORABLE is set, the header must not be modified (we clone the header in that case)
// For speedy singletons, there is the additional problem that the operation expects always to write a FL value to the result area, which is OK for any
// real block but not for an inplaced virtual block, whose virtual data may be shorter than a FL.  The pure solution would be for the singleton code
// to refrain from modifying a virtual block that is shorter than a FL, but that means we would have to test for it for every arithmetic operation.  Thus
// we take the alternative, which is to not mark a virtual block inplaceable if it is a type shorter than a FL.  The type must also be DIRECT since we
// can't keep track of individual usecounts for non-DIRECT blocks.
//
// Note: arithmetic dyads on bytes have similar issues, because the 8-byte-at-a-time operations may execute outside the cell of the array.  We detect
// those cases inside the atomic-dyad code in va2.c.
#define TYPEVIPOK       (FL+CMPX+SBT+(SZI==SZD?INT:0))
// NOUNSAFE flag
// scaf expunge all the following
#define SAFE(x)         (x)    // type, current block and descendants safe from tstack
#define SAFED(x)        (x)    // type, descendants safe from tstack
#define SAFE0(x)        (x)    // type, current block safe from tstack
#define UNSAFE(x)       (x)   // type, not safe from tstack
#define UNSAFED(x)      (x)   // type, descendants not safe from tstack
#define UNSAFE0(x)      (x)   // type, not safe from tstack

#define TYPESEQ(x,y)    ((x)==(y))  // types are equal, ignoring NOUNSAFE bits
#define TYPESXOR(x,y)    ((x)^(y))  // types are not equal, ignoring NOUNSAFE bits, using full-word logical
#define TYPESNE(x,y)    ((x)!=(y))  // types are equal, ignoring NOUNSAFE bits
#define TYPESLT(x,y)    ((x)<(y))  // type x < type y
#define TYPESGT(x,y)    ((x)>(y)) // type x > type y

// Utility: keep the lowest 1 only
#define LOWESTBIT(x)    ((x)&-(x))

#define HOMO(s,t)       (TYPESEQ((s),(t)) || HOMONE((s),(t)) )
#define HOMONE(s,t)     ( !(((s)|(t))&(BOX|SBT|JCHAR|MARK)) || !(((s)|(t))&(BOX|SBT|NUMERIC|MARK)) )   // if known to be not equal.  One arg may be MARK (in indexofsub) but must show non-HOMO
#define STYPE(t)        (((t)&(B01|LIT|INT|FL|CMPX|BOX))<<(SB01X-B01X))
#define DTYPE(t)        (((t)&(SB01|SLIT|SINT|SFL|SCMPX|SBOX))>>(SB01X-B01X))

// Flags in the count field of type A
#define ACINPLACE       (I)((((UI)-1)>>1)^(UI)-1)  // set when this block CAN be used in inplace operations.  Always the sign bit.
#define ACPERMANENT     ((I)((UI)ACINPLACE>>1))  // next-to-top bit, set in blocks that should never modify the AC field
#define ACUSECOUNT      (I)1  // lower bits used for usecount
#define ACIPNO(a)       (AC(a)&=~ACINPLACE)
#define ACIPYES(a)      (AC(a)|=ACINPLACE)
#define ACIPISOK(a)     (AC(a)<1)  // OK to modify if INPLACE set - set only when usecount=1
#define ACUC(a)         (AC(a)&(~ACINPLACE))  // just the usecount portion
#define ACUC1           (ACUSECOUNT*1) // <= this is usecount==1; > is UC>1
#define ACINCR(a)       if(!ACISPERM(AC(a)))(AC(a)=(AC(a)+1)&~ACINPLACE)
#define ACX(a)          {AC(a)=ACPERMANENT;}
#define ACISPERM(c)     (((c)+(c))<0)  // is PERMANENT bit set?
#define ASGNINPLACE(w)  (ACIPISOK(w) || AC(w)==1&&jt->assignsym&&jt->assignsym->val==w&&!(AFLAG(w)&AFRO)&&notonupperstack(w))  // OK to inplace ordinary operation
// same, but s is an expression that is neg if it's OK to inplace
#define ASGNINPLACESGN(s,w)  (((s)&AC(w))<0 || ((s)&(AC(w)-2))<0 &&jt->assignsym&&jt->assignsym->val==w&&!(AFLAG(w)&AFRO)&&notonupperstack(w))  // OK to inplace ordinary operation
#define ASGNINPLACESGNNJA(s,w)  ( ((s)&AC(w))<0 || (((s)&(AC(w)-2))<0||(((s)&(AC(w)-3)&SGNIF(AFLAG(w),AFNJAX))<0))&&jt->assignsym&&jt->assignsym->val==w&&!(AFLAG(w)&AFRO)&&notonupperstack(w))  // OK to inplace ordinary operation
// define virtreqd and set it to 0 to start   scaf no LIT B01 C2T etc
// This is used in apip.  We must ALWAYS allow inplacing for NJA types, but for ordinary inplacing we don't bother if the number of atoms of w pushes a over a power-of-2 boundary
#define EXTENDINPLACENJA(a,w)  ( ((AC(a)&(((AN(a)+AN(w))^AN(a))-AN(a)))<0) || (AC(a)==1||(AC(a)==2&&AFLAG(a)&AFNJA))&&((jt->assignsym&&jt->assignsym->val==a&&!(AFLAG(a)&AFRO))||(!jt->assignsym&&(virtreqd=1,!(AFLAG(a)&(AFRO|AFVIRTUAL)))))&&notonupperstack(a))  // OK to inplace ordinary operation

/* Values for AFLAG(x) field of type A                                     */
// the flags defined here must be mutually exclusive with TRAVERSIBLE

#define AFRO            (I)1            /* read only; can't change data    */
#define AFNJAX          1            /* non-J alloc; i.e. mem mapped    */
#define AFNJA           ((I)1<<AFNJAX)
#define AFNVRX          8
#define AFNVR           ((I)1<<AFNVRX)  // This value is on the parser's execution stack, and must not be freed until it is removed
#define AFUNIFORMITEMSX 16      // matches SBTX
#define AFUNIFORMITEMS  ((I)1<<AFUNIFORMITEMSX)  // It is known that this boxed array has contents whose items are of uniform shape and type
#define AFNVRUNFREEDX   18
#define AFNVRUNFREED    ((I)1<<AFNVRUNFREEDX)  // This value does NOT need to be freed by the parser, even though it was stacked
#define AFVIRTUALX      17      // matches C2TX
#define AFVIRTUAL       ((I)1<<AFVIRTUALX)  // this block is a VIRTUAL block: a subsequence of another block.  The data pointer points to the actual data, and the
                                 // m field points to the start of the block containing the actual data.  A VIRTUAL block cannot be incorporated into another block, and it
                                 // cannot be assigned, unless it is 'realized' by creating another block and copying the data.  We realize whenever we call ra() on the block,
                                 // except during the EPILOG, where we don't realize the block unless the real block is about to be freed.
#define AFUNINCORPABLEX 19      // matches XDX
#define AFUNINCORPABLE  ((I)1<<AFUNINCORPABLEX)  // (used in result.h) this block is a virtual block used for subarray tracking and must not
                                // ever be put into a boxed array, even if WILLBEOPENED is set, because it changes
#define AFAUDITUCX      32   // this & above is used for auditing the stack (you must run stack audits on a 64-bit system)
#define AFAUDITUC       ((I)1<<AFAUDITUCX)    // this field is used for auditing the tstack, holds the number of deletes implied on the stack for the block

// Flags in the AR field of local symbol tables
#define LSYMINUSE 1  // This bit is set in the rank of the original symbol table when it is in use
#define LNAMEADDED LPERMANENT  // Set in rank when a new name is added to the local symbol table.  We transfer the bit from the L flags to the rank-flag
#define LLOCALTABLE 16  // Set in rank of all local symbol tables.  This indicates that the first hashchain holds x/y info and should not be freed as a symbol

#define SFNSIMPLEONLY 1   // to sfn: return simple name only, discarding any locative

#define FIXALOCSONLYLOWEST 4  // to fixa: replace only the first occurrence of u/v in each branch
#define FIXALOCSONLY 8  // to fixa: replace only u/v (IMPLOC)


typedef struct {I i;US n,go,source;C type;C canend;} CW;

/* control word (always has corresponding token string)                             */
/* type   - as specified in w.h                                            */
/* go     - line number to go to                                           */
/* source - source line number                                             */
/* i      - beginning index of token string                                */
/* n      - length          of token string                                */
// canend - Indicates that the most-recent B-block result can (1) or can't (2) become the result of the running definition.  0 means we don't know yet.


#define DCPARSE  1      /* sentence for parser                                          */
#define DCSCRIPT 2      /* script              -- line()                                */
#define DCCALL   3      /* verb/adv/conj call  -- dbunquote()                           */
#define DCJUNK   4      /* stack entry is stale                                      */

typedef struct DS{      /* 1 2 3                                                        */
 struct DS*dclnk;       /* x x x  link to next stack entry                              */
 A dcy;                 /* x x x  &tokens; text       ; right argument                  */
 I dcn;                 /* x x x  #tokens; line #     ; ptr to symb entry               */
 I dcix;                // x x x  index ; next index  ; line# in exp def being executed, or to be exec next
 I dcj;                 /* x x x  error#; prev index  ; error #                         */
 C dctype;              /* x x x  type of entry (see #define DC*)                       */
 B dcsusp;              /* x   x  1 iff begins a debug suspension                       */
 C dcss;                /*     x  single step code                                      */
 C dcnewlineno;         //     x  set when debug has installed a new line number into dcix
 A dca;                 /*     x  fn/op name                                            */
 A dcf;                 /*     x  fn/op                                                 */
 A dcx;                 /*     x  left argument                                         */
 A dcloc;               /*     x  local symb table (0 if not explicit)                  */
 A dcc;                 /*     x  control matrix   (0 if not explicit)                  */
 I dcm;                 /*   x x        ; script index; # of non-locale part of name    */
 I dcstop;              /*     x  the last stop in this function                        */
} DST;

typedef DST* DC;


typedef struct {I e,p;X x;} DX;
                                /* for the p field in DX */
#define DXIPREC         ((I)-1) /* infinite precision    */
#define DXINF           ((I)-2) /* _  infinity           */
#define DXMINF          ((I)-3) /* __ negative infinity  */

/* extended floating point                                                 */
/* e - exponent                                                            */
/* p - precision & other codes                                             */
/*        +ve   # of significant digits                                    */
/*        _1    infinite precision (with trailing 0s)                      */
/*        _2    infinity _                                                 */
/*        _3    negative infinity __                                       */
/* x - mantissa                                                            */
/*        least significant digit first                                    */
/*        decimal point after last digit                                   */

#define SYMLINFO 0  // index of LINFO entry
#define SYMLINFOSIZE 1     // Number of symbol-table entries that DO NOT contain symbol chains, but instead are LINFO entries

typedef struct {A name,val;US flag;S sn;LX next;} L;

/* symbol pool entry                         LINFO entry (named/numbered)      */
//-------------------------------------------------------------------------
/* name - name on LHS of assignment          locale name                    */
/* val  - value                              locale search path              */
// flag - various flags                      locale flags                 
/* sn   - script index                              not used                   */
/* next - index of successor in hash list or 0      mot used                  */

// FOR EXECUTING LOCAL SYMBOL TABLES: AK() points to the active global symbol table, AM() points to the calling local symbol table.
// In all local symbol tables, the first 'hashchain' has the symbol offsets of x/y

#define LCH             (I)1            /* changed since last exec of 4!:5 */
#define LHEAD           (I)2            /* head pointer (no predecessor)   */
#define LINFO           (I)4            /* locale info                     */
#define LPERMANENT      (I)8            // This is a permanent entry in a local symbol table; don't delete, just leave val=0
#define LHASNAME        (I)16      // name is nonnull
#define LHASVALUE       (I)32     // value is nonnull
// in LINFO entry
#define LMOD            (I)1          // table has had new entries added (used for local symbol tables only)


// Definition of callstack

typedef struct {
 I type;  // type of entry, flagged per below
 void *value;  // locale or name, depending on the type
} LS;
#define CALLSTACKPOPLOCALE 2  // value is jt->global that must be restored after function returns
#define CALLSTACKPOPFROM 4  // value is jt->global that must be modified in the caller of this function also
#define CALLSTACKCHANGELOCALE 8  // value is jt->global that was changed within execution of this name
#define CALLSTACKPOPLOCALEFIRST 16  // set in the POPLOCALE that is added when the first POPFROM is seen
#define CALLSTACKPUSHLOCALSYMS 32  // value is jt->locsyms that must be restored
#define CALLSTACKDELETE 256  // the given locale must be deleted, and this is the earliest place on the stack that refers to it

// Add an entry to the call stack, and increment the index variable
#define pushcallstack(i,t,v) (jt->callstack[i].type=(t), jt->callstack[i].value=(v), ++i)
#define pushcallstack1(t,v) {ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}
#define pushcallstack1d(t,v) {FDEPDEC(d); ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}


typedef struct{UI4 hash;I4 bucket;I bucketx;UC m;C flag,s[1];} NM;

/* hash: hash for  non-locale part of name                                 */
// bucket: (for local simple names) the index of the hash chain for this symbol when viewed as a local
//   0 if chain index not known or name is a locative
// bucketx: (for local simple names, only if bucket!=0) the number of chain entries to discard before
//   starting name search.  If negative, use one's complement and do not bother with name search - symbol-table entry
//   is guaranteed to be at that position
//   (for direct locatives) the hash of the locative - if numbered, the number itself.
//   (for indirect locatives) hash of the last indirect name
//   (for locale names in SYMLINFO of a numbered locale) the locale number 
// m:    length of non-locale part of name note 255-byte limit! (AN holds the length of the entire name including the locative)
/* s:    string part of full name (1 to ?? characters, including locale of assignment if given)           */

#define NMLOC           1       /* direct   locale abc_lm_                 */
#define NMILOC          2       /* indirect locale abc__de__fgh ...        */
#define NMDOT           4       /* one of the names m. n. u. v. x. y.      */
#define NMXY            8       // x/y, which must have NAMEBYVALUE set
#define NMIMPLOC        16      // this NM block is in u./v.


typedef struct {I a,e,i,x;} P;

/* value fields of sparse array types                                      */
/* fields are offsets from beginning of the P struct                       */
/* a: sparse axes                                                          */
/* e: sparse element                                                       */
/* i: index matrix, columns correspond to a                                */
/* x: value cells corresponding to rows of i                               */

#define SPA(p,a)        ((A)((p)->a+(C*)(p)))  // a is one of aeix; result is A pointer for that component
#define SPBV(p,a,v,x)      {RZ(v = (x)); INCORP(v); (p)->a=(C*)v-(C*)(p);}  // store x into component (a); return if x is 0.  a is one of aeix.  Result in v
#define SPB(p,ZWa,x)      {A ZWo = (x); SPBV((p),ZWa,ZWo,(x))}  // store x into component (a); return if x is 0.  a is one of aeix

// Header for hashtables used in i.
// This sits at the beginning of the allocated block, holding info about the stored values
typedef struct {
 I datasize;   // number of bytes in the data area
 I hashelelgsize;  // lg(size of a hashed element)
 UI currentlo;   // the lowest position in the hashtable of the current allocation.
 UI currenthi;   // the highest position+1 of the current allocation.
 UI currentindexofst;   // the value in the hashtable that the minimum value in the input will map to
 UI currentindexend;    // the highest value that can possibly be written, +1
 UI previousindexend;  // All positions from 0 to currenthi are known to be less than currentindexend.
             // Positions from currenthi to the end are known to be less than previousindexend.
 UI invalidlo;   // the start of the area that does not have constrained values because it was used for a bit table (as an index into hashtable, rounded up to multiple of I for endian reasons)
 UI invalidhi;   // the end+1 of the area used for a bit table  (as an index into hash table, rounded up to multiple of I)
 I datamin;  // (for small-range use) minimum value in the data
 UI datarange;  // (for small-range use) range+1 of the data
 // 11 words here; 7 words of header (we allocate no shape); 2 words of memory-allocation header; so this block is 20 words after the
 // memory allocation, and thus is on the same 256-bit boundary as the allocation.
 union {   // We index into the data with varying strides, depending on the range of the data
  UC UC[1];  // cannot have union of 
  US US[1];
  UI4 UI4[1];
  UI UI[1];
 } data;
} IH;
#define IHAV(x)         ((IH*)((C*)(x)+AK(x)))  //  how to refer to the header area

// Return value from condrange
typedef struct {
 I min;  // smallest value found
 I range;  // max+1-min, or 0 if range exceeds max given
} CR;

/* performance monitoring stuff */

typedef struct{
 A name;                /* verb/adverb/conjunction name                    */
 A loc;                 /* locale name                                     */
 I lc;                  /* line number (-1 for entry; -2 for exit)         */
 I s;                   /* space                                           */
 I t[2];                /* time                                            */
 C val;                 /* valence: 1 or 2                                 */
 C unused[3];           /* padding                                         */
} PM;

#define PMCOL  6        /* # of fields in PM                               */

typedef struct{
 I n;                   /* maximum number of records                       */
 I i;                   /* index of next record to be written              */
 I s;                   /* initial bytesmax value                          */
 B rec;                 /* what to record (0 entry & exit; 1 all)          */
 B trunc;               /* what to do on overflow (0 wrap; 1 truncate)     */
 B wrapped;             /* 1 iff wrapping has happened                     */
 C unused[1];           /* padding                                         */
} PM0;


/* each unique symbol has a row in jt->sbu                                 */
/* a row is interpreted per SBU                                            */
/* for best results make sizeof(SBU) a multiple of sizeof(I)               */
 
typedef struct{
 I  i;                  /* index into sbs                                  */
 I  n;                  /* length                                          */
 UI h;                  /* hash value                                      */
 I  color;              /* binary tree: color                              */
 I  parent;             /* binary tree: index of parent                    */
 I  left;               /* binary tree: index of left  child               */
 I  right;              /* binary tree: index of right child               */
 I  order;              /* order number                                    */
 I  down;               /* predecessor in ordering                         */
 I  up;                 /* successor   in ordering                         */
 I  flag;               /* bit flags                                       */
} SBU;

#define SBC2  1         /* 1 iff 2-byte character                          */
#define SBC4  2         /* 2 iff 4-byte character                          */



typedef struct {AF valencefns[2];A fgh[3];union { D lD; void *lvp[2]; I lI; I4 lI4[4]; I lclr[2]; AF lfns[2];} localuse;I4 flag;UI4 flag2; RANK2T lrr; RANKT mr; C id; C lc;} V;  // two cachelines exactly
// the localuse fields is not freed or counted for space, as the f/g/h fields are.  It is for local optimizations only.  We put if first so that the rest of
// the block, which is used more, is in a single cacheline.  Local uses are:
// for ATOMIC2 ops, pointer to the adocv block
// for name references, pointer to last resolution
// for FIT conj, the CCT data
// for RANK conj, lI4[0-2] has the signed ranks
// for Fold final operator, pointer to the dyadic EP of the handler (xdefn or unquote)

// lc is a local-use byte.  Used in atomic dyads to indicate which singleton function to execute
// in the derived function from fold, lc has the original id byte of the fold op

#define ID(f)           (f&&FUNC&AT(f)?FAV(f)->id:C0)
#define VFLAGNONE 0L
#define VRTNNONE ((A)0)
  
                                        /* type V flag values              */
// bits 0-7 are used in comparison compounds to encode the type of compound, see vcompsc.c
// for other types, they are defined as follows:
#define VFATOPL         JTINPLACEW     // (in forks and v0`v1`v2) f/v0 is x@[, so OK to inplace w arg of h
#define VFATOPR         JTINPLACEA     // (in forks and v0`v1`v2) f/v0 is x@], so OK to inplace a arg of h
#define VFHKLVLDECX     0   // (in (compare L.) hooks) set for > and <: to indicate increment of x needed before levelle
#define VFHKLVLDEC      (((I)1)<<VFHKLVLDECX)
#define VFHKLVLGTX      1   // (in (compare L.) hooks) set for < and <: to indicate complement of result of levelle needed
#define VFHKLVLGT       (((I)1)<<VFHKLVLGTX)

// bits 8 and above are available for all functions:
#define VGERLX          8
#define VGERL           (((I)1)<<VGERLX)          /* gerund left  argument           */
#define VGERR           (I)512          /* gerund right argument           */
#define VTAYFINITE      (I)1024         /* t. finite polynomial            */
#define VIRS1           (I)2048         /* 11 monad has integral rank support */
#define VIRS2           (I)4096         /* 12 dyad  has integral rank support */
#define VFLR            (I)8192         /* function is <.@g                */
#define VCEIL           (I)16384        /* function is >.@g                */
#define VMOD            (I)32768        /* function is m&|@g               */
#define VLOCK           (I)65536        /* function is locked              */
#define VNAMED          (I)131072       /* named explicit defn             */
#define VFIX            (I)262144       /* f. applied                      */
#define VXOPR           (I)524288       /* : defn with u. and x.           */
#define VXOP            (I)1048576      /* : defn derived fn               */
#define VXOPCALL        (I)2097152      /* : defn derived fn call          */
#define VTRY1           (I)4194304      /* monad contains try.             */
#define VTRY2           (I)8388608      /* dyad  contains try.             */
#define VDDOP           (I)16777216     /* 24 derived from a derived operator */
#define VJTFLGOK1X    25    // 25 monad can handle in-place args
#define VJTFLGOK1     (((I)1)<<VJTFLGOK1X)
#define VJTFLGOK2X    26    // 26 dyad can handle in-place args
#define VJTFLGOK2     (((I)1)<<VJTFLGOK2X)
#define VASGSAFE        ((I)(1L<<27))     // does not alter locale/path
#define VISATOMIC1      ((I)(1L<<28))     // processes each atom individually (logically rank 0, but handles all ranks)
#define VISATOMIC2      ((I)(1L<<29))    // dyad is atomic.  localuse will point to the VA entry for the verb
#define VFUSEDOK2  ((I)(1L<<30))    // this block can be executed by passing in another block (containing rank) whose fgh[0] points to the native block for this primitive

// bits in flag2:
// bit 0 unused
#define VF2BOXATOP1X      1   // This verb is one of  <  <@f   <@:f   <&f   <&:f    f&.>  f&.:>
#define VF2BOXATOP1     ((I)(((I)1)<<VF2BOXATOP1X))
#define VF2BOXATOP2X      2   // This verb is one of  <@f   <@:f   f&.>  f&.:>
#define VF2BOXATOP2     ((I)(((I)1)<<VF2BOXATOP2X))
// next flag must be same as JTWILLBEOPENED
#define VF2WILLOPEN1X      4   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN1       ((I)(((I)1)<<VF2WILLOPEN1X))
// must leave a gap for WILLBEOPENED in result.h
#define VF2ISCCAPX        5   // flags (if any) came from ([: g h) rather than f@:g
#define VF2ISCCAP         ((I)(((I)1)<<VF2ISCCAPX))
// next flag must be same as JTCOUNTITEMS
#define VF2USESITEMCOUNT1X 7   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT1  ((I)(((I)1)<<VF2USESITEMCOUNT1X))
// must leave a gap for COUNTITEMS in result.h
// next 3 flags must be spaced from VF2BOXATOP? to match spacing in ZZFLAGS
#define VF2ATOPOPEN1X     8   // This verb is one of  > @> &> &.>
#define VF2ATOPOPEN1     ((I)(((I)1)<<VF2ATOPOPEN1X))
#define VF2ATOPOPEN2WX    9   // This verb is one of  &> &.>
#define VF2ATOPOPEN2W     ((I)(((I)1)<<VF2ATOPOPEN2WX))
#define VF2ATOPOPEN2AX    10   // This verb is one of  &> &.>
#define VF2ATOPOPEN2A     ((I)(((I)1)<<VF2ATOPOPEN2AX))
#define VF2RANKATOP1X     11   // set if this verb starts out with rank loop and thus can be subsumed into a higher rank loop
#define VF2RANKATOP1     ((I)(((I)1)<<VF2RANKATOP1X)) 
#define VF2RANKATOP2X     12   // set if this verb starts out with an outer rank loop.  " @ & &. and not special-cased
#define VF2RANKATOP2     ((I)(((I)1)<<VF2RANKATOP2X))
#define VF2RANKONLY1X     13   // set if this verb is u"r, not special-cased (i. e. function points to rank processing).  The rank may be subsumed into a higher rank before we see arguments.
#define VF2RANKONLY1     ((I)(((I)1)<<VF2RANKONLY1X)) 
#define VF2RANKONLY2X     14
#define VF2RANKONLY2     ((I)(((I)1)<<VF2RANKONLY2X))
// Next 4 flags must be spaced so they can shift down to WILLOPEN1 and COUNTITEMS1
#define VF2WILLOPEN2WX      15   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN2W       ((I)(((I)1)<<VF2WILLOPEN2WX))
#define VF2WILLOPEN2AX      16   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN2A       ((I)(((I)1)<<VF2WILLOPEN2AX))
#define VF2USESITEMCOUNT2WX 18   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT2W  ((I)(((I)1)<<VF2USESITEMCOUNT2WX))
#define VF2USESITEMCOUNT2AX 19   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT2A  ((I)(((I)1)<<VF2USESITEMCOUNT2AX))



typedef struct {DX re;DX im;} ZX;

/* extended complex                                                        */
/* re - real part                                                          */
/* im - imaginary part                                                     */


// parser stack - this MUST have size equal a power of 2!!
typedef struct {
  // Because the parse decode looks mostly at pt, make that the first thing so that it is always aligned to the beginning
  // of whatever block is usd to copy one stack element to another.
 UI4 pt;  // parser type: code for one of the 9 variants recognized.
 UI4 t;  // token number for this block
 A a;  // pointer to block
} PSTK;

// stack frame used by the parser
 typedef struct{
  PSTK* parserstkbgn;     // &start of parser stack
  PSTK* parserstkend1;    // &end+1 of parser stack
  A    *parserqueue;   // for error purposes: words of the sentence being parsed
  US   parserqueuelen;  // number of words in queue
  US   parsercurrtok;   // the token number of the word to flag if there is an error
  US  nvrtop;           /* top of nvr stack; # valid entries               */
  US  nvrotop;          // previous top of nvr stack
 } PFRAME;  // these are stacked en bloc


// Info for calling an atomic verb
typedef struct {VF f;I cv;} VA2;
